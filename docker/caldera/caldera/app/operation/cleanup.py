import logging
from ..engine.objects import ObservedHost, Operation, ObservedRat, ObservedFile, ObservedRegKey, ObservedShare, \
    ObservedSchtask, ObservedService, Host, JobException
from ..commands import taskkill, cmd, net, sc, schtasks, reg
from ..commands.powershell import PSArg, PSFunction, escape_string_literally
from ..commands.errors import *
from .operation import InterfaceWrapper
from ..util import CaseException
from ..commands.command import CommandLine
from typing import Callable, Union

log = logging.getLogger(__name__)


class Cleaner(object):
    """Handles cleaning up, instances of this class are passed in as the first argument to a cleanup function."""
    def __init__(self, operation, interface: InterfaceWrapper):
        self._server_operation = operation
        self.interface = interface
        self.op_log = operation._operation

    async def delete(self, obj) -> None:
        if isinstance(obj, ObservedRat):
            iv = self._server_operation.rat_of_ob(obj)
            await kill_process(self.op_log, iv.host, obj.pid, self.run_on_agent)
        elif isinstance(obj, ObservedFile):
            await delete_file(self.op_log, obj.host, obj.path, self.run_on_agent)
        elif isinstance(obj, ObservedRegKey):
            await delete_registry_key(self.op_log, obj.host, self.run_on_agent, key=obj.key, value=obj.value,
                                      path_to_file=obj.path_to_file)
        elif isinstance(obj, ObservedShare):
            await unmount_share(self.op_log, obj.src_host, obj.dest_host.fqdn, obj.share_name, self.run_on_agent)
        elif isinstance(obj, ObservedSchtask):
            await delete_task(self.op_log, obj.host, obj.name, self.run_on_agent)
        elif isinstance(obj, ObservedService):
            await stop_service(self.op_log, obj.host, obj.name, self.run_on_agent)
            await delete_service(self.op_log, obj.host, obj.name, self.run_on_agent)
        else:
            raise CaseException

    async def revert_timestamp(self, host, obj: ObservedFile) -> None:
        """
        A separate function to clean up timestamps
        Takes an ObservedFile object and passes its old timestamps to the reset_timestamp
        interface function
        Args:
            host: the host object to clean up on
            obj: the file to revert timestamps on
        """
        await revert_timestamp(self.op_log, obj.host, obj.path, obj.old_creation_time, obj.old_last_write,
                               obj.old_last_access, self.run_on_agent)

    async def run_on_agent(self, host, cmd: CommandLine, parser: Callable[[str], str]) -> Union[str, None]:
        success = False
        job = None
        tries = 0

        real_host = Host.objects(fqdn=host.fqdn).first()
        while not success:
            job = self.interface.agent_shell_command(real_host, cmd.command_line)
            try:
                await job.wait_till_completed()
                success = True
            except JobException as e:
                log.warning("Job failed with: {}".format(e.args))
                tries += 1
                if tries == 3:
                    log.warning("Job failed 3 times in a row. Stop trying to run it")
                    return

        return parser(job.host_command_result().output)


async def console_log(op: Operation, host: ObservedHost, msg: str):
    """
    Handles error reporting
    Args:
        op: The operation currently being run
        host: The host the command was to be run on
        msg: The error message (generated by caller)

    Returns:
        Nothing
    """
    log.warning(msg)
    op.modify(push__clean_log={"host": host.fqdn, "error": msg})


async def spawn_recovery_rat(target_host: ObservedHost, user: str, password: str, domain: str, operation):
    actual_host = operation.host_of_ob(target_host)
    await operation._interface.write_commander(actual_host, 'C:\cleanup.exe').wait_till_completed()
    queue = operation.start_listening_for_rat()
    await operation._interface.create_process_as_user(actual_host, 'C:\cleanup.exe -f', domain,
                                                      user, password).wait_till_completed()
    observed_rat = await operation.wait_for_rat(queue, {"host": target_host.id}, None)
    return observed_rat


async def clean_recovery_rat(ob_rat: ObservedRat, ob_file: ObservedFile, cleaner):
    await cleaner(ob_rat)
    await cleaner(ob_file)


async def rat_operation(op, ob_rat: ObservedRat, interface_func, *args):
        rat = op.rat_of_ob(ob_rat)
        job = interface_func(rat, *args)
        tries = 0
        try:
            await job.wait_till_completed()
        except JobException as e:
            log.warning("Job failed with: {}".format(e.args))
            tries += 1
            if tries == 3:
                log.warning("Job failed 3 times in a row. Stop trying to run it")
                return

        return job.rat_result()


async def kill_process(op: Operation, host: ObservedHost, pid: int, job_run_until_success) -> bool:
    """
    Kills the specified process pid on the desired host
    Args:
        op: The operation currently being run
        host: The host to run the command on
        pid: The pid to kill
        job_run_until_success: A function that will be passed the arguments to run the job

    Returns:
        True if successful otherwise False
    """
    try:
        await job_run_until_success(host, *taskkill.by_pid(pid))
    except NoProcessError:
        msg = 'Process "{}" not found on {}'.format(pid, host.fqdn)
        await console_log(op, host, msg)
    return True


async def delete_file(op: Operation, host: ObservedHost, file_path: str, job_run_until_success) -> bool:
    """
    Deletes a file on the given host
    Args:
        op: The operation currently being run
        host: The host to delete the file on
        file_path: The path of the file to be deleted
        job_run_until_success: A function that will be passed the arguments to run the job

    Returns:
        True if successful otherwise False
    """
    try:
        await job_run_until_success(host, *cmd.delete(file_path))
    except AccessDeniedError:
        msg = 'Access denied to "{}" on {}'.format(file_path, host.fqdn)
        await console_log(op, host, msg)
    except NoFileError:
        msg = 'File "{}" not found on {}'.format(file_path, host.fqdn)
        await console_log(op, host, msg)
    except (NoNetworkPathError, PathSyntaxError) as e:
        msg = 'Caught a {} while trying to delete file "{}" on {}'.format(type(e).__name__, file_path, host.fqdn)
        await console_log(op, host, msg)
    return True


async def unmount_share(op: Operation, host: ObservedHost, remote_host: str, share_name: str, job_run_until_success)\
        -> bool:
    """
    Unmounts a share on the given system

    Args:
        op: The operation currently being run
        host: The host to delete the share on
        remote_host: The remote host, i.e. the computer hosting the share
        share_name: The name of the share (with '$')
        job_run_until_success: A function that will be passed the arguments to run the job

    Returns:
        True if successful otherwise False.
    """
    try:
        await job_run_until_success(host, *net.use_delete(remote_host, share_name))
    except NoShareError:
        msg = 'Share "\\\\{}\\{}" not found on {}'.format(remote_host, share_name, host.fqdn)
        await console_log(op, host, msg)
    return True


async def delete_service(op: Operation, host: ObservedHost, service_name: str, job_run_until_success) -> bool:
    """
    Deletes services created during an operation

    Args:
        op: The operation currently being run
        host: The host the service should be deleted from.
        service_name: The name of the service to be deleted.
        job_run_until_success: A function that will be passed the arguments to run the job

    Returns:
        True on success
    """
    try:
        await job_run_until_success(host, *sc.delete(service_name))
    except NoServiceError:
        msg = 'Service "{}" does not exist on {}'.format(service_name, host.hostname)
        await console_log(op, host, msg)
        return False
    return True


async def delete_task(op: Operation, host: ObservedHost, task_name: str, job_run_until_success) -> bool:
    """
    Deletes a scheduled task.

    Args:
        op: The operation currently being run
        host: The host to delete the task on.
        task_name: The name of the task to be deleted.
        job_run_until_success: A function that will be passed the arguments to run the job

    Returns:
        True if successful, otherwise False.
    """
    try:
        await job_run_until_success(host, *schtasks.delete(task_name, force=True))
    except ParseError:
        msg = 'Unknown error encountered with schtasks on {}'.format(host.hostname)
        await console_log(op, host, msg)
        return False
    return True


async def delete_registry_key(op: Operation, host: ObservedHost, job_run_until_success, key: str=None, value: str=None,
                              path_to_file: str=None) -> bool:
    """
    Deletes registry keys created during an operation

    Args:
        op: The operation currently being run
        host: the host to delete the key from
        key: The registry key to delete
        value: Which value for the key should be deleted.
        path_to_file: If a hive was loaded from a file to have a new key inserted into it.  Key will be relative.
        job_run_until_success: A function that will be passed the arguments to run the job

    Returns:
        True if successful
    """
    if path_to_file:  # Key is relative, we need to load the hive.
        try:
            await job_run_until_success(host, *reg.load(key="HKU\\temp", file=path_to_file))
        except AccessDeniedError:
            msg = 'Tried to delete the reg key {} on host {} but access was denied to load the hive'\
                .format(key, host.hostname)
            await console_log(op, host, msg)
            return False

    try:
        if path_to_file:  # Key is relative, we need to load this hive.
            await job_run_until_success(host, *reg.delete(key="HKU\\temp\\{}".format(key), value=value, force=True))
        else:  # Key is absolute
            await job_run_until_success(host, *reg.delete(key=key, value=value, force=True))
    except NoRegKeyError:
        msg = 'Tried to delete the reg key {} with value {} that does not exist on {}'.format(key, value, host.hostname)
        await console_log(op, host, msg)
        return True
    finally:
        if path_to_file:
            await job_run_until_success(host, *reg.unload(key="HKU\\temp"))

    return True


async def stop_service(op: Operation, host: ObservedHost, service_name: str, job_run_until_success) -> bool:
    """
    Stops a service.

    Args:
        op: The operation currently being run
        host: The host to delete the task on.
        service_name: The name of the service to be stopped.
        job_run_until_success: A function that will be passed the arguments to run the job

    Returns:
        True if successful, otherwise False.
    """
    try:
        await job_run_until_success(host, *sc.stop(service_name))
    except (ServiceNotStartedError, NoServiceError):
        msg = "Unable to Stop Service - Service Not Currently Running"
        await console_log(op, host, msg)
        pass  # this is fine in our case if it isn't already running

    return True


async def revert_timestamp(op: Operation, host: ObservedHost, path: str, creation_time: str, last_write: str,
                           last_access: str, job_run_until_success):
    """
    Builds a Powershell command to change the timestamps of a specified file and passes it as an argument
    to the cmd.powershell function for processing.
    Params:
        OP: The operation currently being run
        host: The host where the file to revert timestamps is located.
        path: The absolute file path of the file to revert timestamps
        creation_time: The creation date/time of the file BEFORE it was timestomped
        last_write: The last write date/time of the file BEFORE it was timestomped
        last_access: The last access date/time of the file BEFORE it was timestomped
        job_run_until_success: A function that will be passed the arguments to run the job
    """
    ps_command = ("$FileItem = Get-Item \"\"\"{0}\"\"\" ; "
                  "$FileItem.CreationTime = \"\"\"{1}\"\"\" ; "
                  "$FileItem.LastWriteTime = \"\"\"{2}\"\"\" ; "
                  "$FileItem.LastAccessTime = \"\"\"{3}\"\"\"")

    ps_command = ps_command.format(path, creation_time, last_write, last_access)

    try:
        await job_run_until_success(host, *cmd.powershell(ps_command))
    except FileNotFoundError:
        msg = 'While reverting timestamps, could not find file {} on {}'.format(path, host.hostname)
        await console_log(op, host, msg)
        return False
    except AccessDeniedError:
        msg = 'Tried to revert timestamp of "{}" on {} but access was denied'.format(path, host.hostname)
        await console_log(op, host, msg)
        return False
    return True
